# Отсортируйте по убыванию методом пузырька одномерный целочисленный массив,
# заданный случайными числами на промежутке [-100; 100).
# Выведите на экран исходный и отсортированный массивы.
# Примечания:
# ● алгоритм сортировки должен быть в виде функции,
# которая принимает на вход массив данных,
# ● постарайтесь сделать алгоритм умнее, но помните,
# что у вас должна остаться сортировка пузырьком.
#  Улучшенные версии сортировки, например, расчёской, шейкерная
# и другие в зачёт не идут.

import random
import timeit


def buble1(data):
    for i in range(len(data)-1):
        for j in range(i+1, len(data)):
            if data[i] < data[j]:
                data[i], data[j] = data[j], data[i]
    return data


# оптимизация путем проверки факта перестановки. После каждого прохода по
# внутреннему циклу где воможна перестановка мы фиксируем ее если она была.
# И если ее так и не случилось, то дальше по внешнему циклу не идем.
def buble2(data):
    for i in range(len(data)-1):
        change = False
        for j in range(i+1, len(data)):
            if (data[i] < data[j]):
                data[i], data[j] = data[j], data[i]
                change = True
        if change is False:
            break

    return data


N = 10
arr = [random.randint(-100, 99) for i in range(N)]
arr_copy = arr

print(arr)

arrsort = buble2(arr_copy)
print(arrsort)

print(arr)

# После вызова функции buble(любой), почему то сортируется исходный массив arr,
# даже если я подаю в функцию копию этого массива. Не пойму в чем тут дело,
# видимо функция все равно сортирует исходный массив, как то добираясь по сслыкам
# в памяти до исходного массива. Функция же работает с копией входных данных?
# Как ей удается сам arr затронуть?

# Из-за этого не сравнить два варианта, так как
# во второй приходит уже отсортированный массив после первой функции.

# То есть напрямую не могу сравнить насколько buble2 быстрее buble1.

# Пришлось отдельно включать каждую функцию. Итого buble1 на N=10000 около 7-8 с.
# Для buble2 примерно столько же, как будто и нет разницы.
# Но я делал при number=1, иначе при следующих вызовах на вход приходит
# уже отсортированный массив. При больших number разница должна быть,
# по крайней мере по логике buble2.

# time1 = timeit.timeit('buble1(arr)', number=1, globals=globals())
# print(time1)

# time2 = timeit.timeit('buble2(arr)', number=1, globals=globals())
# print(time2)
